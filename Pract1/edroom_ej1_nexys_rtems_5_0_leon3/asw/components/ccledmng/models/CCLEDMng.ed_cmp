import "../../../dataclasses/TEDROOMUInt8/models/TEDROOMUInt8.ed_dclass";
import "../../../dataclasses/TEDROOMUInt32/models/TEDROOMUInt32.ed_dclass";
import "../../../dataclasses/TEDROOMBool/models/TEDROOMBool.ed_dclass";
import "../../../dataclasses/Pr_Time/models/Pr_Time.ed_dclass";
import "../../../protocols/CPLEDMngCtrl/models/CPLEDMngCtrl.ed_prot";
import "../../../protocols/EDROOMTimingSAP/models/EDROOMTimingSAP.ed_prot";
import "../../../protocols/EDROOMServiceLibrary/models/EDROOMServiceLibrary.ed_prot";
import "../../../sais/nexys_gpio_drv_v1/models/nexys_gpio_drv_v1.ed_sai";



/**
 * \class   CCLEDMng
 *
 */


reactive component CCLEDMng{

	uri := es.uah.aut.srg.edroom.mclev.cmp.CCLEDMng;
	version := v1;
	stack_size := 1024;
	def_max_nb_messages := 10;
	requires := nexys_gpio_drv(v1);




	structure {

		ports {


			system port EDROOMsl
			{
				id:= 0;
				protocol:= EDROOMServiceLibrary(v1);
			};
			timing port Timer {
				id := 1;
				protocol := EDROOMTimingSAP(v1);

			};

			external port LEDMngCtrl {
				id := 2;
				cardinality := 1;
				protocol := CPLEDMngCtrl(v1);

			};



		};


	};


	behaviour {

		contexts {


			context Top_0{


				id := 0;


				variables {
					variable CMaxShiftPeriodMicrosecs{
					 class := TEDROOMUInt32(v1);

					 constructor := "900000";
					 dimension := 0;
					};
					variable VLEDPos{
					 class := TEDROOMUInt8(v1);

					 constructor := "0";
					 dimension := 0;
					};
					variable VShiftDirection{
					 class := TEDROOMBool(v1);

					 constructor := "0";
					 dimension := 0;
					};
					variable VShiftPeriodMicrosecs{
					 class := TEDROOMUInt32(v1);

					 constructor := "100000";
					 dimension := 0;
					};
					variable VTimeRef{
					 class := Pr_Time(v1);

					 constructor := "";
					 dimension := 0;
					};


				};


				constants {
					constant CMinShiftPeriodMicrosecs{
					 class := TEDROOMUInt32(v1);

					 constructor := "100000";
					 dimension := 0;
					};


				};


				states {
					state I{
						id := 0;
					};
					state Idle{
						id := 1;
					};
					state Ready{
						id := 2;
					};
				};


				init state := I;


				items{
					/**
					 * \brief  
					 */

					msgdatahandler FGetShiftPeriod {
						code {
							<code>
							 
							// Data access
							 
							VShiftPeriodMicrosecs=varSLEDStart*100000;
							 
							//Limit Period	
							if(VShiftPeriodMicrosecs &gt; CMaxShiftPeriodMicrosecs)
								VShiftPeriodMicrosecs=CMaxShiftPeriodMicrosecs;
							else if (varSLEDStart &lt; CMinShiftPeriodMicrosecs)
								VShiftPeriodMicrosecs=CMinShiftPeriodMicrosecs;
							 
							//Get Time reference
							VTimeRef.GetTime();


							</code>
						};

						port :=LEDMngCtrl;

						message :=CPLEDMngCtrl(v1)::SLEDStart;

					};

					/**
					 * \brief  
					 */

					inform at FProgShift {
						code {
							<code>
							 
							 
							 VTimeRef+=Pr_Time(0,VShiftPeriodMicrosecs); // interval of X sec + Y microsec	 
							  
							 time= VTimeRef;


							</code>
						};

						port :=Timer;

						priority :=3;

					};

					/**
					 * \brief  
					 */

					reply FReplyLEDShiftToggled {
						code {
							<code>
							VShiftDirection=!VShiftDirection;


							</code>
						};

						message :=CPLEDMngCtrl(v1)::SLEDShiftToggled;

					};

					/**
					 * \brief  
					 */

					send FSendLEDReady {
						code {
							<code>


							</code>
						};

						port :=LEDMngCtrl;

						message :=CPLEDMngCtrl(v1)::SLEDReady;

						priority :=3;

					};

					/**
					 * \brief  
					 */

					action FShiftLEDs {
						<code>
						nexys_srg_gpio_turn_off_led(VLEDPos);
						 
						if(VShiftDirection){
						 
							VLEDPos=(VLEDPos + 1)%10;
						}else{
							if(VLEDPos){
								VLEDPos--;
							}else{
								VLEDPos=9;
							}
						}
						 
						nexys_srg_gpio_turn_on_led(VLEDPos);


						</code>

					};


				};


				transitions{

					transition Init{
						id := 0;
						source := I;
						sink := Idle;



						asynchronous trigger {
							port := EDROOMsl;
							message := EDROOMServiceLibrary(v1)::EDROOMStart;
						};
					};

					transition Start{
						id := 1;
						source := Idle;
						sink := Ready;


						msgdatahandler := FGetShiftPeriod;

						actions := FProgShift;

						sends := FSendLEDReady;


						asynchronous trigger {
							port := LEDMngCtrl;
							message := CPLEDMngCtrl(v1)::SLEDStart;
						};
					};

					transition ShiftTimeout{
						id := 2;
						source := Ready;
						sink := Ready;


						actions := FShiftLEDs, FProgShift;


						asynchronous trigger {
							port := Timer;
							message := EDROOMTimingSAP(v1)::EDROOMSignalTimeout;
						};
					};

					transition ToggleShift{
						id := 3;
						source := Ready;
						sink := Ready;


						reply := FReplyLEDShiftToggled;


						synchronous trigger {
							port := LEDMngCtrl;
							message := CPLEDMngCtrl(v1)::SToggleLEDShift;
						};
					};


				};


			};


		};

		top context := Top_0;


	};


};